<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>kernel on Nihaal</title>
    <link>https://nihaal.me/tags/kernel/</link>
    <description>Recent content in kernel on Nihaal</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Tue, 15 Feb 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://nihaal.me/tags/kernel/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Using static checkers on Linux Kernel</title>
      <link>https://nihaal.me/post/static_checker/</link>
      <pubDate>Tue, 15 Feb 2022 00:00:00 +0000</pubDate>
      
      <guid>https://nihaal.me/post/static_checker/</guid>
      <description>One of the hurdles in contributing to Linux kernel as a beginner is to find something to work on. If you are working as a kernel developer or are a part of a kernel mentorship program, this shouldn&amp;rsquo;t be a problem. But for others, the first step is to send a bunch of coding style fixes for warnings reported by checkpatch.
In addition to checkpatch, there are many other static analysis tools like sparse, coccinelle and smatch, used to analyse source code and find possible bugs.</description>
    </item>
    
    <item>
      <title>Creating sysfs files</title>
      <link>https://nihaal.me/post/creating_sysfs_files/</link>
      <pubDate>Mon, 29 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nihaal.me/post/creating_sysfs_files/</guid>
      <description>The kernel provides a few ways in which userspace programs can get information from the kernel space.
 procfs: Used to get information about running processes debugfs: Used by kernel developers for debugging sysfs  Sysfs is used for data that is not related to a particular process. It has information about hardware devices attached to the system and about drivers handling those devices.
Any file added to the sysfs becomes a part of the Linux Application Binary Interface (ABI).</description>
    </item>
    
    <item>
      <title>Looking inside /dev/null</title>
      <link>https://nihaal.me/post/dev_null/</link>
      <pubDate>Sat, 20 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nihaal.me/post/dev_null/</guid>
      <description>Accessing hardware devices like files An important role of the operating system is to allow the user applications to access hardware resources. It has to allow the user programs to use hardware while also ensuring that the applications have permissions to access it and don&amp;rsquo;t misuse them.
To simplify access to hardware, Unix, by design, exposes most of the hardware devices to userspace as device files, usually present under /dev directory.</description>
    </item>
    
    <item>
      <title>Creating debugfs files</title>
      <link>https://nihaal.me/post/creating_debugfs_files/</link>
      <pubDate>Sat, 06 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nihaal.me/post/creating_debugfs_files/</guid>
      <description>debugfs debugfs is a pseudo-filesystem used for kernel debugging. It is usually mounted at /sys/kernel/debug. debugfs contains files that allow us to read debugging information.
By default, only the root user can cd into the /sys/kernel/debug directory.
To change it to allow the current user to cd into debugfs, we can remount it with uid set to the current user&amp;rsquo;s uid.
1 2 3  sudo umount /sys/kernel/debug sudo mount -t debugfs none /sys/kernel/debug -o uid=`echo $UID` cd /sys/kernel/debug   Creating debugfs entries Creating debugfs files is similar to creating character device files.</description>
    </item>
    
    <item>
      <title>Misc character devices</title>
      <link>https://nihaal.me/post/misc_char_devices/</link>
      <pubDate>Wed, 03 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nihaal.me/post/misc_char_devices/</guid>
      <description>Character Devices, Major and Minor numbers Based on granularity of access, there are two classes of devices:
 Character devices are accessed as a stream of bytes. Eg: Keyboards Block devices are accessed in blocks. For instance, hard disks transfer data in blocks of multiple bytes at a time.  The kernel uses major and minor numbers to identify the attached hardware devices. Major number usually tells us the type of device.</description>
    </item>
    
    <item>
      <title>Eudyptula Challenge task 5</title>
      <link>https://nihaal.me/post/ec5/</link>
      <pubDate>Tue, 12 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://nihaal.me/post/ec5/</guid>
      <description>In this post, I want to share what I learnt by doing task 5 of the Eudyptula challenge.
The Eudyptula Challenge is a set of 20 tasks designed to help people get started with Linux kernel development.
Task 5 of the challenge is to make a hello world kernel module get loaded automatically when a USB keyboard is plugged in.
Loadable kernel modules Linux kernel allows us to load modules to the kernel while the kernel is running.</description>
    </item>
    
    <item>
      <title>Hello world Linux Kernel Module</title>
      <link>https://nihaal.me/post/hello_world_lkm/</link>
      <pubDate>Fri, 31 Jan 2020 10:42:00 +0530</pubDate>
      
      <guid>https://nihaal.me/post/hello_world_lkm/</guid>
      <description>A Loadable Kernel Module (LKM) is a piece of code that can be loaded to a running kernel to add additional functionality to the kernel. The code that runs as a kernel module will be executed with kernel privileges. Most operating system kernels support kernel modules.
The advantage of using kernel modules is that it can be loaded to and unloaded from the kernel without the need to recompile or reboot the kernel.</description>
    </item>
    
  </channel>
</rss>
