<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Coccinelle - Nihaal</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="Abdun Nihaal" /><meta name="description" content="Coccinelle is static analysis tool used for semantic pattern matching and automated transformation of C programs. It is written in OCaml. Unlike other pattern matching tools like grep which use regular expressions, Coccinelle understands C syntax and can find semantic code pattern in the source code and automatically transform them, irrespective of the name of identifiers, comments or formatting.
Coccinelle is intraprocedural, i.e. all its matching and transformation happens within functions." />






<meta name="generator" content="Hugo 0.126.1 with theme even" />


<link rel="canonical" href="https://nihaal.me/post/coccinelle/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.f92fd13721ddf72129410fd8250e73152cc6f2438082b6c0208dc24ee7c13fc4.css" rel="stylesheet">
<link href="/lib/fancybox/jquery.fancybox-3.1.20.min.css" rel="stylesheet">


<meta property="og:url" content="https://nihaal.me/post/coccinelle/">
  <meta property="og:site_name" content="Nihaal">
  <meta property="og:title" content="Coccinelle">
  <meta property="og:description" content="Coccinelle is static analysis tool used for semantic pattern matching and automated transformation of C programs. It is written in OCaml. Unlike other pattern matching tools like grep which use regular expressions, Coccinelle understands C syntax and can find semantic code pattern in the source code and automatically transform them, irrespective of the name of identifiers, comments or formatting.
Coccinelle is intraprocedural, i.e. all its matching and transformation happens within functions.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2022-12-14T00:00:00+00:00">
    <meta property="article:modified_time" content="2022-12-14T00:00:00+00:00">
    <meta property="article:tag" content="Linux">
    <meta property="article:tag" content="Kernel">

  <meta itemprop="name" content="Coccinelle">
  <meta itemprop="description" content="Coccinelle is static analysis tool used for semantic pattern matching and automated transformation of C programs. It is written in OCaml. Unlike other pattern matching tools like grep which use regular expressions, Coccinelle understands C syntax and can find semantic code pattern in the source code and automatically transform them, irrespective of the name of identifiers, comments or formatting.
Coccinelle is intraprocedural, i.e. all its matching and transformation happens within functions.">
  <meta itemprop="datePublished" content="2022-12-14T00:00:00+00:00">
  <meta itemprop="dateModified" content="2022-12-14T00:00:00+00:00">
  <meta itemprop="wordCount" content="1355">
  <meta itemprop="keywords" content="Linux,Kernel">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Coccinelle">
  <meta name="twitter:description" content="Coccinelle is static analysis tool used for semantic pattern matching and automated transformation of C programs. It is written in OCaml. Unlike other pattern matching tools like grep which use regular expressions, Coccinelle understands C syntax and can find semantic code pattern in the source code and automatically transform them, irrespective of the name of identifiers, comments or formatting.
Coccinelle is intraprocedural, i.e. all its matching and transformation happens within functions.">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

<script defer data-domain="nihaal.me" src="https://stats.nihaal.me/js/script.js"></script>
<script>
  (function(w, d, t, h, s, n) {
    w.FlodeskObject = n;
    var fn = function() {
      (w[n].q = w[n].q || []).push(arguments);
    };
    w[n] = w[n] || fn;
    var f = d.getElementsByTagName(t)[0];
    var v = '?v=' + Math.floor(new Date().getTime() / (120 * 1000)) * 60;
    var sm = d.createElement(t);
    sm.async = true;
    sm.type = 'module';
    sm.src = h + s + '.mjs' + v;
    f.parentNode.insertBefore(sm, f);
    var sn = d.createElement(t);
    sn.async = true;
    sn.noModule = true;
    sn.src = h + s + '.js' + v;
    f.parentNode.insertBefore(sn, f);
  })(window, document, 'script', 'https://assets.flodesk.com', '/universal', 'fd');
</script>

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">Nihaal</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">Nihaal</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Coccinelle</h1>

      <div class="post-meta">
        <span class="post-time"> 14-12-2022 </span>
        
          <span class="more-meta"> 1355 words </span>
          <span class="more-meta"> 7 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#installing-and-using-coccinelle">Installing and using Coccinelle</a></li>
        <li><a href="#writing-semantic-patches">Writing Semantic patches</a>
          <ul>
            <li><a href="#rules-syntax">Rules syntax</a></li>
            <li><a href="#advanced-features">Advanced features</a></li>
          </ul>
        </li>
        <li><a href="#coccinelle-internals">Coccinelle Internals</a></li>
        <li><a href="#references">References</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>Coccinelle is static analysis tool used for semantic pattern matching and automated transformation of C programs.
It is written in OCaml.
Unlike other pattern matching tools like grep which use regular expressions, Coccinelle understands C syntax and
can find semantic code pattern in the source code and automatically transform them, irrespective of the name of identifiers, comments or formatting.</p>
<p>Coccinelle is <em>intraprocedural</em>, i.e. all its matching and transformation happens within functions.
Coccinelle also does not expand C macros.</p>
<p>It can be used for</p>
<ol>
<li>
<p>Fixing bugs based on the bug pattern. For example, whenever we allocate memory using kmalloc, we have to check if the return value is NULL.
Using coccinelle, we can find places in the code where the check is not performed.
This allows us to &ldquo;Find (a bug) once, Fix everywhere&rdquo;.</p>
</li>
<li>
<p>Performing <em>collateral evolutions</em>, i.e. making a change that needs to be propagated throughout the codebase.
For example, a change in the arguments used for a function needs updating all the points in the code where that function is called.
Similarly, there could be old deprecated functions that need to be replaced by new alternatives.</p>
</li>
</ol>
<p>Coccinelle takes as input the C program files that need to be matched and transformed, and a <em>semantic patch</em>.
Semantic patches are coccinelle scripts written in Semantic Patch Language (SmPL), that specifies the code pattern that needs to be matched
and the code transformation that needs to be performed.
The syntax of semantic patches is similar to C and the notations used in patches (eg: <em>+</em> to denote added lines and <em>-</em> to denote deleted lines).</p>
<h2 id="installing-and-using-coccinelle">Installing and using Coccinelle</h2>
<ul>
<li>
<p>To install coccinelle from source</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>  git clone https://github.com/coccinelle/coccinelle
</span></span><span style="display:flex;"><span>  cd coccinelle
</span></span><span style="display:flex;"><span>  ./autogen
</span></span><span style="display:flex;"><span>  ./configure
</span></span><span style="display:flex;"><span>  make
</span></span><span style="display:flex;"><span>  sudo make install
</span></span></code></pre></div><p>This will install a tool called <strong>spatch</strong>, which is like the <em>patch</em> tool but for semantic patches.
We use spatch for applying semantic patches.</p>
</li>
<li>
<p>To check if your semantic patch is valid:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>  spatch --parse-cocci your_patch.cocci
</span></span></code></pre></div></li>
<li>
<p>To apply or run your patch on a file or directory:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>  spatch --sp-file your_patch.cocci file.c
</span></span><span style="display:flex;"><span>  spatch --sp-file your_patch.cocci --dir directory
</span></span></code></pre></div></li>
<li>
<p>To set a virtual dependency (like report,patch,org) use -D flag:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>  spatch -D report --sp-file your_patch.cocci file.c
</span></span></code></pre></div></li>
</ul>
<h2 id="writing-semantic-patches">Writing Semantic patches</h2>
<ul>
<li>Writing semantic patches
<ul>
<li>Write a patch for the change</li>
<li>Abstract unneeded code with <em>dots</em> (&hellip;)</li>
<li>Abstract over identifiers, expressions and constants with <em>metavariables</em></li>
<li>Check for matches and refine incrementally for special cases</li>
</ul>
</li>
</ul>
<h3 id="rules-syntax">Rules syntax</h3>
<p>A semantic patch consists of many <em>rules</em> and each rule consists of two parts:</p>
<ol>
<li>Metavariable declaration</li>
<li>Transformation specification</li>
</ol>
<p>The general structure of a rule is given below: (The rule name is optional.)</p>
<pre tabindex="0"><code class="language-Coccinelle" data-lang="Coccinelle">@rule_name@
// Metavariable declaration
@@
// Transformation specification
</code></pre><h4 id="metavariable-declaration">Metavariable declaration</h4>
<p>Metavariables are used to abstract over identifiers, expressions, constants and types.
For example, if I use a metavariable of type <em>expression</em> , it can match over any C expression.
We can also use metavariables of a specific struct or type defined in the program.</p>
<h4 id="transformation-specification">Transformation specification</h4>
<ul>
<li>
<p>Matching code</p>
<p>We can use (three) dot symbols: <strong>&hellip;</strong> to match any code. This allows us to match lines irrespective of
the code present between the lines.
However, in some situations, we may want to restrict the code that we want to skip.
For this, we can use the <strong>when</strong> clause along with the dots.</p>
<ul>
<li><strong>&hellip;</strong> matches any code</li>
<li><strong>&hellip; when != e</strong> matches any code which is not equivalent to the expression e.</li>
<li><strong>&lt;&hellip; x &hellip;&gt;</strong> matches the expression represented by <em>x</em>, zero or more times.</li>
<li><strong>&lt;+&hellip; x &hellip;+&gt;</strong> matches the expression represented by <em>x</em>, one or more times.</li>
</ul>
</li>
<li>
<p>Transforming code</p>
<p>The left most column specifies the transformation that needs to be performed.
The following symbols have special meaning when used as the first character in a line:</p>
<ul>
<li><strong>+</strong>  adds the line to the matched code</li>
<li><strong>-</strong>   removes the matched line</li>
<li><strong>*</strong>   highlights the matched line</li>
<li><strong>( | )</strong> Disjunction allows us to specify multiple possible match patterns</li>
</ul>
</li>
</ul>
<h4 id="examples">Examples</h4>
<ol>
<li>
<p>Replace expressions of the form 1 &lt;&lt; C with the macro BIT(C) where C is any constant.</p>
<pre tabindex="0"><code class="language-Coccinelle" data-lang="Coccinelle">      @@
      constant C;
      @@

      - 1 &lt;&lt; C
​      + BIT(C)
</code></pre></li>
<li>
<p>Using <em>disjunction</em>: Replace expressions of the form 1 &lt;&lt; C with BIT(C) where C is any constant, and
replace expressions of the form 1 &lt;&lt; E with BIT(E) where E is any expression.</p>
<pre tabindex="0"><code class="language-Coccinelle" data-lang="Coccinelle">      @@
      constant C;
      expression E;
      @@

      {
​      - 1 &lt;&lt; C
​      + BIT(C)
      |
​      - 1 &lt;&lt; E
​      + BIT(E)
      }
</code></pre></li>
<li>
<p>Using <em>identifiers</em> and <em>dots</em>: Replace assignment to a local variable followed by immediate return of that value,
by simply the return statement.
Notice here, we don&rsquo;t care about what the arguments of the function is, and so we can use dots there.</p>
<pre tabindex="0"><code class="language-Coccinelle" data-lang="Coccinelle">      @@
      identifier f;
      expression r;
      @@

      - r = f(...);
​      + return f(...);
​      - return r;
</code></pre></li>
<li>
<p>Matching zero or more function calls using <strong>&lt;&hellip; &hellip;&gt;</strong></p>
<pre tabindex="0"><code class="language-Coccinelle" data-lang="Coccinelle">      @@
      identifier f;
      @@
      *f(...)
      {
      &lt;...
​      * g(...)
      ...&gt;
      }
</code></pre></li>
</ol>
<h3 id="advanced-features">Advanced features</h3>
<h4 id="rule-dependencies">Rule dependencies</h4>
<p>We can specify dependency between rules. This allows matching a rule only if another rule has been matched.
For example, the following sematic patch has two rules. The first rule matches if the BIT macro is used anywhere
in the file. If it is used, then the second rule which <em>depends</em> on the first rule converts expressions 1 &lt;&lt; E into BIT(E).</p>
<pre tabindex="0"><code class="language-Coccinelle" data-lang="Coccinelle">   @usesbit@
   @@
   BIT(...)

   @depends on usesbit@
   expression E;
   @@

   - 1 &lt;&lt; E
   + BIT(E)
</code></pre><p>We can also pass values between rules with dependency using <strong>&lt;&lt;</strong> syntax inside the metavariable declaration.</p>
<pre tabindex="0"><code class="language-Coccinelle" data-lang="Coccinelle">   @usesbit@
   expression E;
   @@
   1 &lt;&lt; E

   @depends on usesbit@
   expression E &lt;&lt; usesbit.E;
   @@

   - 1 &lt;&lt; E
   + BIT(E)
</code></pre><h4 id="isomorphisms">Isomorphisms</h4>
<p>Coccinelle can also find and match code that is equivalent to the expression that we want to match. These statements that are semantically equivalent are called <em>Isomorphisms</em>.
For example, the following statements are equivalent and so when we try to match <em>(x==NULL)</em>, Coccinelle also tries to match the other three statements.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#f92672">!</span>x  <span style="color:#f92672">&lt;=&gt;</span>  x <span style="color:#f92672">==</span> NULL  <span style="color:#f92672">&lt;=&gt;</span>  NULL <span style="color:#f92672">==</span> x;
</span></span></code></pre></div><p>Coccinelle provides a set of default isomorphisms in <em>/usr/lib/coccinelle/standard.iso</em>.
We can use custom isomorphisms by writing them in a file, let&rsquo;s say in custom.iso and using it in the semantic patches with <strong>using</strong> keyword. We can apply a custom isomorphism file-wide or for a specific rule.</p>
<pre tabindex="0"><code class="language-coccinelle" data-lang="coccinelle">using &#34;custom.iso&#34;
@rule1@
expression e;
@@
*e
</code></pre><pre tabindex="0"><code class="language-coccinelle" data-lang="coccinelle">@rule1 using &#34;custom.iso&#34;@
expression e;
@@
*e
</code></pre><h4 id="embedding-python-or-ocaml-scripts">Embedding Python or Ocaml scripts</h4>
<p>We can also embed scripts written in Python or OCaml, inside the semantic patches and have them run when specific rules are matched.
The rules that contain script code should uses <strong>script:python</strong> or <strong>script:ocaml</strong> in the rulename part.</p>
<pre tabindex="0"><code class="language-coccinelle" data-lang="coccinelle">@zero_variable@
identifier i;
@@
i = 0;

@script:python depends on zero_variable@
i &lt;&lt; zero_variable.i;
@@
print (f&#34;Identifier {i} was set to zero&#34;)
</code></pre><h4 id="position-metavariables">Position metavariables</h4>
<p>Coccinelle also provides <em>position</em> metavariables that can be attached to other metavariables (by appending with @) to find and print the position of the match
inside the file.</p>
<pre tabindex="0"><code class="language-coccinelle" data-lang="coccinelle">@zero_variable@
identifier i;
position p;
@@
i@p = 0;

@script:python depends on zero_variable@
i &lt;&lt; zero_variable.i;
p &lt;&lt; zero_variable.p;
@@

print (f&#34;Identifier {i} was set to zero in file {p[0].file}, in function {p[0].current_element} at line {p[0].line}.&#34;)
</code></pre><h4 id="universal-and-existential-quantification">Universal and Existential quantification</h4>
<p>todo</p>
<ul>
<li>when with exists and strict</li>
</ul>
<h2 id="coccinelle-internals">Coccinelle Internals</h2>
<p>In <a href="https://web.imt-atlantique.fr/x-info/coccinelle/stuart_thesis.pdf">Hunting bugs with Coccinelle</a>, it is mentioned that Coccinelle has three parts:</p>
<ol>
<li>A C parser that converts C code into an <em>Abstract Syntax Tree</em> (AST) and a <em>Control Flow Graph</em> (CFG), without expanding all macros.</li>
<li>A parser that converts semantic patches into a formula expressed in Computation Tree Logic with existentially quantified program variables (CTL-VW).
I don&rsquo;t know what CTL-VW is, but I&rsquo;m guessing it is a way to mathematically express code patterns in a program with multiple execution paths.</li>
<li>A model checker that compares the CTL-VW formula with the AST and performs any modifications if specified.</li>
</ol>
<p>After the modifications are done, the AST and CFG are unparsed to produce the modified C code.</p>
<h2 id="references">References</h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=buZrNd6XkEw">Julia Lawall: An Introduction to Coccinelle Bug Finding and Code Evolution for the Linux Kernel</a></li>
<li><a href="https://www.youtube.com/watch?v=2sfJ9HNlU5w">Coccinelle: Finding bugs in the Linux Kernel - Vaishali Thakkar - FOSSASIA Summit 2017</a></li>
<li><a href="https://www.youtube.com/watch?v=xA5FBvuCvMs">Keynote: Inside the Mind of a Coccinelle Programmer by Julia Lawall, Developer of Coccinelle</a></li>
<li><a href="http://coccinellery.org">http://coccinellery.org</a></li>
<li><a href="https://web.imt-atlantique.fr/x-info/coccinelle/stuart_thesis.pdf">Hunting bugs with Coccinelle</a> (Henrik Stuart&rsquo;s Thesis)</li>
</ul>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">Abdun Nihaal</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
        14-12-2022
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/linux/">linux</a>
          <a href="/tags/kernel/">kernel</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/fixing_syzbot_bugs/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Fixing syzbot bugs</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/syzkaller/">
            <span class="next-text nav-default">Finding bugs with Syzkaller</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
  <div id="fd-form-66f8239b39c4e02019d4d467"></div>
  <script>
      window.fd('form', {
          formId: '66f8239b39c4e02019d4d467',
          containerEl: '#fd-form-66f8239b39c4e02019d4d467'
      });
  </script>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="https://www.twitter.com/nihaal_an" class="iconfont icon-twitter" title="twitter"></a>
      <a href="https://in.linkedin.com/in/abdun-nihaal-289272143" class="iconfont icon-linkedin" title="linkedin"></a>
      <a href="https://www.github.com/nifey" class="iconfont icon-github" title="github"></a>
      <a href="https://www.gitlab.com/nihaal" class="iconfont icon-gitlab" title="gitlab"></a>
  
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2016 - 
    2024<span class="heart"><i class="iconfont icon-heart"></i></span><span>Abdun Nihaal</span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  <script type="text/javascript" src="/lib/fancybox/jquery.fancybox-3.1.20.min.js"></script>



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>








</body>
</html>
